# java基础语法


### 目录

<!--GFM-TOC -->
* [注释](#注释)：单行、多行、文档、嵌套
* [关键字](#关键字)：定义、特点
* [标识符](#标识符)：组成规则、命名规范
* [常量](#常量)：常量分类
* [变量](#变量)：概述、定义格式、定义注意事项
* [计算机存储单元](#计算机存储单元)：bit-B-KB-MB-GB-TB-...
* [数据类型](#数据类型)：基本数据类型、引用数据类型、类型转换：显式隐式
* [运算符](#运算符)：算术运算符、赋值运算符、关系运算符、逻辑运算符、三元运算符、位运算符
* [程序流程控制](#程序流程控制)：顺序结构、选择结构(if,switch)、循环结构(for,while,do…while)
* [数组](#数组)：一维数组、二维数组、数组初始化、对象地址值、数组常见问题
* [java内存分配](#java内存分配)：5片内存区、栈、堆、数组示例图解
* [方法](#方法)：方法概述、方法格式、写方法、方法调用、方法重载、方法参数传递问题
* [基础语法练习](#基础语法练习)：月份对应季节、斐波那契数列、数组元素反转、加密数字
<!--GFM-TOC -->



## 注释
- 单行注释: `//注释文字`
- 多行注释: `/* 注释文字 */`
  - eclipse中，输入`/*`之后直接回车即可显示多行注释，并且光标定位在可输入注释位置。
- 文档注释: `/** 注释文字 */`
- 注释的作用: 解释说明程序，提高程序的阅读性
- 注释的嵌套：
  - 单行可以相互嵌套，多行可以嵌套单行，多行不可嵌套多行。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 关键字
- 关键字：被Java语言赋予特定含义的单词
- 关键字特点：
  - 全部小写；
  - 常见的代码编辑器会对关键字有特殊的颜色标记。
  - 熟悉常见关键字，可以会考查：
    - 数据类型，数据类型值，修饰符，类类关系，实例相关，异常处理，包等。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 标识符
- 作用：包,类,方法,变量等的命名
- 组成规则
  - 由字符(字母汉字数字)，下划线_，美元符$组成
    - 字符：unicode字符集，包括英文大小写字母，中文字符，数字字符等；不建议使用中文字符。
  - 不能以数字开头(美元符号、下划线都可以)；
  - 不能是Java中的关键字。 
- 命名规则：见名知意
  - 包(文件夹) ：全部小写，多级包用点隔开。xxxyyyzzz，com.itheima。
  - 类：每个单词首字母大写。XxxYyyZzz。
  - 变量或者方法：第一个单词首字母小写，从第二个单词开始每个单词首字母大写。xxxYyyZzz。
- java源码命名：java文件名应与代码中public类的名字相同。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 常量
- 常量：在程序执行的过程中，其值不可以发生改变的量。
- 常量分类：
  - 字符串常量("")；整数常量；小数常量；字符常量('')；布尔常量(true和false)；空常量(null)。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 变量
- 变量概述：在程序执行的过程中，在某个范围内其值可以发生改变的量
  - 本质讲：变量是内存中的一小块区域。(配合图示食用)
  - 区域限定：用数据类型限定 (eg. 苹果的价格是数字，不能是字符串..)
  - 区域名称：变量名。
  - 区域内容：初始化值。
- 变量定义格式：
  - `数据类型 变量名 = 初始化值;` 
  - `数据类型 变量名; 变量名 = 初始化值;`
- 变量定义的注意事项：
  - 变量未赋值，不能直接使用；(否则会报错’未初始化‘)
  - 注意精度：定义long型或float型需要在数字末尾加L或F标记；
  - 注意范围：变量只在所属范围内有效，范围用大括号划分(代码块)；
  - 同一范围内，变量名不能重复；
  - 同一行可以定义多个变量，但是不建议 (看起来更清楚一些)。
- 关于变量与代码块的测试：
  - 不能同名，但代码块中的变量不能在代码块外使用
	
	```java
	//测试1：代码块内外变量重名
	int a = 123;
	{
		int a = 456; //会报错，提示重名 (虽然是在代码块内外，但第二个a定义时，已经有a这个变量名存在了)
	}
	System.out.println(b);
	```
	
	```java
	//测试2：在代码块以外使用变量
	int a = 123;
	{
		int b = 456;
	}
	System.out.println(b); //会报错，提示找不到符号
	```

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 计算机存储单元
- 变量是内存中的小容器，用来存储数据。
- 计算机存储设备的最小信息单元叫“位（bit）”，又称“比特位”，通常用小写的字母b表示。
- 计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。
- 除了字节外的一些常用的存储单位：1024进率 (特殊: 1B=8bit)
  - bit-B-KB-MB-GB-TB-...	

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 数据类型
- ### Java语言是强类型语言
  - 对于每一种数据都给出了明确的数据类型；
  - 不同的数据类型：分配不同的内存空间，表示不同的数据大小。

- ### 常见数据类型：基本数据类型 + 引用数据类型
  - 基本数据类型：4类8种
    - 整数：byte-1，short-2，int-4，long-8；
    - 浮点数：float-4，double-8；
    - 字符：char-2；
    - 布尔：boolean-1；
    - 注：数字表示所占字节数
  - 引用数据类型：类，数组，接口。
  - 整数默认int型，浮点数默认double型。
  - long类型定义时在数字末尾加L，float类型定义时在数字末尾加F(可小写，建议大写，更清晰)。
    - 否则会报错：整数不加L默认int类型，会报错’过大的整数‘；float不加F默认double类型，会报错’可能损失精度‘。

- ### 数据类型转换：显式/隐式
  - 隐式转换/默认转换：
    - 一般由小到大
    - 运算时，存在更高级类型则自动提升：byte,short,char—>int—>long—>float—>double
    - byte,short,char相互之间不转换，他们参与运算首先转换为int类型
    - boolean类型不能转换为其他的数据类型
  - 显式转换/强制转换：
    - 一般由大到小；可能会损失精度。
    - 格式：`目标类型 变量名=(目标类型)(被转换的数据);`
    - 例如：`byte d = (byte)(a+b);`
    - 建议：数据做运算，结果应该是什么类型就用什么类型接受，不要随意转换类型，否则会有精度的损失。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 运算符
- ### 定义
  - 运算符：对常量和变量进行操作的符号称为运算符.
  - 表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。
    - 不同运算符连接的式子体现的是不同类型的表达式。

- ### 算术运算符
  - 加减乘除 `+,-,*,/` ：
    - 加减乘正常；
    - 除法：注意int相除只能得到int，要想得到小数，就必须有浮点型参与运算。
  - 取余 `%`：
    - 整除的余数；
    - 应用1：对2取余结果为0或1，可以实现开关算法切换；
    - 应用2：任何数对某数取余，结果必小于被取余数，可以实现将结果控制在某数范围内。
  - 取模与取余：
    - Java中取余和取模是不同的，取余是`%`，而取模是`Math.FloorMod()`; c和c++中取模为`%`，而Python中取模为`%`。
    - 取余，遵循尽可能让商向0靠近的原则; 取模，遵循尽可能让商向负无穷靠近的原则(fix()和floor()两个函数的不同)
    - 当a b同正负，则结果一致；当a和b不同正负，则取余结果正负同a，取模结果正负同b。
    - 取余即商的值遵循上条规则基础上尽量靠近0，而取模则使商尽量靠近负无穷
    - 示例：
      - `7 % 4 = 3`, `Math.FloorMod(7,4)=3`;
      - `(-7) % (-4) = -3`, `Math.FloorMod(-7,-4) = -3`.
      - `7 % (-4) = 3`, `Math.floorMod(7, -4) = -1`;
      - `(-7) % 4 = -3`, `Math.floorMod(-7, 4) = 1`.
      - 注：7 % (-4) = (-4)(-1)+3, 而 Math.FloorMod(7,-4) = (-4)(-2)+(-1)
    - 参考链接：[Java取模和取余，你真的弄懂了吗？](https://www.cnblogs.com/doondo/p/14678204.html)
  - 加号 `+`：
    - 数值变量相加是加法运算。
    - 字符参与加法运算：字符在计算机中存储的数据值来参与运算；
      - 常见字符值：`A-65`,`a-97`, `0-48`
    - 字符串参与加法运算：和其他类型的数据做拼接，结果是字符串类型的。
    - 示例：
      - 设置`int a = 10, b = 20;`
      - 则`打印("hello" + a)`，结果是`hello10`，直接拼接；
      - 则`打印("hello" + a + b)`，结果是`hello1020`，直接拼接；
      - 则`打印(a + b + "hello")`，结果是`30hello`，从左往右，先计算后拼接。
  - 自增自减 `++--`：
    - `++--`可以放在变量的左侧或者右侧，均可。
    - 单独使用时，放在左右，结果没有区别；
    - 参与其他运算时：
      - `a++`：先拿变量做操作运算，后变量自增自减；
        - 注：内存表示中，(b=a++为例) 会先取出变量初始值存起来，然后进行运算即a+=1，然后把存起来的初始值赋值给b。
      - `++a`: 先变量自增自减，后拿变量做操作运算。
      - 注：简单记忆为”谁(指变量或加加减减)在前先操作谁“ eg. ，变量在前运算后自增自减，符号在前先自增自减。
    - #### 注意：Python没有这样的自增，是按照正常写`a=a+1;`，或者`a+=1`

- ### 赋值运算符
  - 基本赋值运算符：`=`
    - 与逻辑运算符等等于`==`区别。
  - 扩展赋值运算符：`+=, -=, *=, /=,...`
    - 注意：此类运算符隐含强制类型转换，<即强制转换为左侧的数据类型>。(潜在考点，可能见于笔试小题)
    - 示例：`byte a;`时：`a+=10;`相当于`a=(a的数据类型)(a+10);`，但`a=a+10`就可能因为数据类型不一致而报错。

- ### 关系运算符
  - 符号包含：`==,!=,>,>=,<,<=`
  - 结果类型：关系运算符的结果都是boolean型，true或false。
  - 注意：关系运算符“==”不能误写成“=” 。
    - `输出(a==b)`: 判断a与b是否相等，然后输出比较结果。
    - `输出(a=b)`: 把b的值赋值给a，然后将a的值输出。
    - 注意：如果在布尔型变量位置出现`a=b`，要知道此处的结果。

- ### 逻辑运算符
  - 逻辑运算符用于连接关系表达式
    - 注意：在Java中不可以写成`3<x<6`，应该写成`x>3 && x<6`。
  - 符号包含：`&,|,^,!,&&,||`
    - 与运算`&`：一假即假，全真才真。
    - 或运算`|`：一真即真，全假才假。
    - 异或运算`^`：相同为假，不同为真。(异或即求异)
    - 非运算`!`：只连接一个，转为反面 (注：!!可两个以上相连使用不会报错)。
  - 短路：双与双或 
    - 结果与"单与"和"单或"一样。
    - `&`：两边都参与运算；`&&`：左为false时，右边不执行。
    - `|`：两边都参与运算；`||`：左为true时，右边不执行。
  - 示例：
	  ```java
	  int a = 10, b = 20;
	  System.out.println((a++ > 10) && (b++ > 20));//先算a与10的比较，后a++，不成立则短路，false
	  System.out.println(a);//a=11
	  System.out.println(b);//b=20 短路未执行，因此不变
	  ```

- ### 三元运算符
  - 格式：`(关系表达式)?表达式1：表达式2；`
    - 如果条件为true，运算后的结果是表达式1；
    - 如果条件为false，运算后的结果是表达式2；
  - 获取两个数中大数：
    - `z = (x>y)?x:y;//z变量存储的就是两个数的大数。`
  - 比较两个整数是否相同：
    - `boolean b = (a==b) ? true : false;`
    - `boolean b = (a==b); //其实这样写就可以了，上一行是为了演示三元运算符`
  - 获取三个数中的最大值：
    ```java
    int temp = (a>b) ? a: b;
    int max = (temp>c) ? temp: c;
    ```

- ### 位运算符
  - 左移和右移：
    - 左移：二进制位向左移动，相当于乘以2的次幂运算，移动几位就是几次幂。
    - 右移：二进制位向右移动，相当于除以2的次幂运算，移动几位就是几次幂。（整除）
    - 好处：运算速度快；弊端：只能操作2的倍数。
  - 右移和无符号右移：
    - 右移：最高位补位原则是，原最高位是什么，就补什么；
    - 无符号右移：空位补0。
    - 无符号右移：不用于做除法，用于获取二进制中的某些位。
  - 与`&`、或`|`：同逻辑运算符的位运算。
  - 异或`^`：位相同取1，不同取0。
    - 性质：`a^b^b=a;`，可以用于简单加密。
  - 反码`~`：二进制的每一位，0变成1，1变成0
    - 当n为正数时，`~(n) = -(n+1)`
    - 当n为负数时，`~(-n) = |n| - 1`，忽略负号。
    - 例如：`~6+1 = -6;`，`~(-3) = 2`
  - ### 经典面试题：两个整数互换
    - 三种方法：通过第三方变量；通过和；通过异或。
    - 第三方：`temp = a; a = b; b = temp`
    - 通过和(可能超出范围，慎用)：`a = a+b; b = a-b; a = a-b; //和-自己=另一个数`
    - 通过异或：`a=a^b; b=a^b; a=a^b; //a^b^b=a`
      - `a=a^b;`
      - `b=a^b=(a^b)^b=a;`
      - `a=a^b=(a^b)^a=(b^a)^a=b;` (根据两数异或的原理，可知交换律符合，故可得) 
    
- ### [运算符优先级](https://www.cnblogs.com/anliux/p/12342676.html)
  - 括号>符号>乘除加减>位移>逻辑大于小于>逻辑等等于>与或非>双与双非>三目>赋值(=、某=)
  - <img width="469" alt="1265453-20200221193113530-594239145" src="https://github.com/anliux/JAVALearning/assets/32152091/b8746d47-3813-4a84-adb2-9bdd8c387922">


<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 程序流程控制
- ### 顺序结构
  - 按照代码的先后顺序，依次执行。

- ### 选择结构：
  - 控制语句体的执行与否，又叫分支结构，有if和switch两种。
  - if语句：
    - 格式1：一种情况的判断
    	- 首先执行关系表达式；如果true，就执行语句体；否则为false，则不执行语句体。
		```java
		if(关系表达式)
			{  语句体  }
		```
    - 格式2：两种情况的判断 
    	- 首先执行关系表达式；如果true，就执行语句体1；否则为false，则执行语句体2。
		```java
		if(关系表达式)
			{  语句体1; }
		else
			{ 语句体2; }
		```
    - 格式3：多种情况的判断 
      	- 首先执行关系表达式1，为true则执行语句体1；否则执行表达式2，为true则执行语句体2；...；否则，执行语句体n+1.
      	- 注意：是判断就可能为false，因此若语句体都是对相同变量赋值，如果语句体n+1为空，则会编译报错，需要完善。
		```java
		if(关系表达式1)
	  		{语句体1;}
	  	else if (关系表达式2)
	  		{语句体2;}
	  	…
	  	else
	  		{语句体n+1;}
	  	```
  - switch语句：
    - 关键字：switch，case，default，break。
    - 格式：
	    ```java 
	    
	    switch(表达式) {
		    case 值1：
			语句体1;
			break;
		    case 值2：
			语句体2;
			break;
		    …
		    default：	
			语句体n+1;
			break;
            }
	    
           ```
    - 表达式的取值：byte,short,int,char, JDK5以后可以是枚举, JDK7以后可以是String；	   
    - case后面的值：要和表达式进行比较的值；
      - 注意：case标签不能重复，重复产生了不确定性。
    - 语句体部分可以是一条或多条语句；
    - break表示中断，结束的意思，可以结束switch语句；
      - 注意：如果没有break，则运行到switch语句的最后结束。
    - default语句表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。
      - 注意：无论摆放位置如何，都是按照`case->default`的顺序。
    - 执行流程：计算表达式；将结果与case后的值比较，遇break结束；都不匹配，则执行default。
      - 注意：找到某case或从default执行时，到break或switch末尾结束。
      - 如果某case没break，则继续向下执行下面的case的内容直到遇到break或switch末尾。

- ### 循环结构：
  - 控制语句体循环，直到不再满足循环条件
  - 循环语句的组成：
    - 初始化语句，判断条件语句，循环体语句，控制条件语句。
  - 三种：for, while, do…while
  - for语句：
    - 格式：
      ```java
      for(初始化语句;判断条件语句;控制条件语句)
		{循环体语句;}
      ```
    - 执行流程：
      - 初始化；判断条件语句，false则结束循环，否则继续；循环体语句；控制条件语句；重新执行判断条件语句。
  - 示例：
    - 水仙花数是指一个三位数，其各位数字的立方和等于该数本身。
      - 隐含了范围是100-999，因此`for(int i=100;i<1000;i++){...}`
    - 个位：153%10；十位：153/10%10；百位：153/10/10%10。
    - PS: 水仙花数一共有4个 (153, 370, 371, 407).
  - while循环：
    - 格式：
      ```java
      初始化语句;
      while(判断条件语句)
		{ 循环体语句;
	  	  控制条件语句;  }
      ```
  - do-while循环：
    - 格式：注意，while后面还有分号的。
      ```java
      初始化语句;
      do{
		循环体语句;
		控制条件语句;
      }while((判断条件语句);
      ```
  - 三种循环的区别：
    - do…while循环至少会执行一次循环体。
    - for循环和while循环只有在条件成立的时候才会去执行循环体
    - for循环语句和while循环语句的小区别：
      - 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用；
      - 因此，如果想继续使用，就用while，否则推荐使用for。
      - 此处注意：变量有效范围。
    - 三种循环选取优先级：for > while > do while.
  - break和continue：
    - 两者都只能用在循环中 (脱离使用场景则没有意义)。
    - break：
      - 使用场景：switch语句；循环。
      - 作用：跳出单层循环。即默认作用于所在循环。例如位于内层时break则跳出内循环。
      - 注意：若内层break控制外循环，则可以使用标记符号标记内外循环。
      - 示例：(continue也可以这样使用)
		```Java
		outer: for(){ //注意冒号别丢了
		    inter: for(){
		        ....;
			break: outer;//直接跳出外循环。
			//continue: outer; //继续外循环。
		    }
		}
		```
    - continue：
      - 使用场景：循环。
    - 注意：break和continue如果单独存在，该条语句下面都不可以有语句(永远执行不到的废物语句，会报错)
    - 两者的区别：break-退出当前循环；continue-退出本次循环，并继续下次循环。
  - 无限循环：
    - 格式：`while(true){}`, `for(,,){}`
    - 存在的原因：并不知道循环多少次，而是根据某些条件来控制循环；控制循环语句一般放在循环体中，并配合break等使用。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 数组
- ### 一维数组
  - 概述：
    - 数组是存储同一种数据类型多个元素的容器。
    - 数组既可以存储基本数据类型，也可以存储引用数据类型。
  - 特点注意：
    - 元素类型必须一致；
    - 元素有整数索引；
    - 长度一旦定义好就无法改变；
    - 可以存储基本数据类型，也可存储引用数据类型。
  - 定义数组：
    - 格式1：`数据类型[] 数组名;` -- 推荐使用
    - 格式2：`数据类型 数组名[];`
    - 注意：这两种定义做完了，数组中是没有元素值的。需要初始化。     
  - 数组的初始化：
    - 定义：为数组中的数组元素分配内存空间，并为每个数组元素赋值。
    - 分类：
      - 动态初始化：初始化时只指定数组长度，由系统为数组分配初始值(默认初始化)。
      - 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。
    - 动态初始化：
      - 格式：`数据类型[] 数组名 = new 数据类型[数组长度];`
        - new：为数组申请内存分配，开辟空间。
	- 未指定数组元素时，通过数值名输出地址值，例如打印arr输出 ` [I@15db9742 `
	- 地址值 `[I@15db9742 `： 一个方括号表示一维数组，I表示int型，` @ `是分隔符，后面是哈希值。
	- 访问数组元素：使用索引值。例如`arr[i]`。
    - 静态初始化：
      - 格式：`数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};`
        - 注意后面小括号不定义数组长度，以免不一致造成不确定性。
      - 简写：`数据类型[] 数组名 = {元素1,元素2,…};`，例如：`int[] arr = {1,2,3};`
    - 数组属性：length -- 获取数组中元素的个数。
      - 使用：`数组名.length;`
    - 数组获取最值的思路：
      - 注意：参照物从数组元素中取，否则容易出现取太大超过所有数组元素的情况。

- ### 二维数组
  - 概述：二维数组其实就是元素为一维数组的数组。
  - 定义格式：
    - `数据类型[][] 数组名;` -- 推荐
    - `数据类型 数组名[][];` -- 不推荐
    - `数据类型[] 数组名[];` -- 不推荐
  - 初始化方式：
    - 动态初始化：`数据类型[][] 变量名 = new 数据类型[m][n];`
      - m：二维数组中的一维数组的个数，n：一维数组的元素个数。
    - 静态初始化：`数据类型[][] 变量名 = new 数据类型[][]{{元素…},{元素…},{元素…}};`
      - 简化版格式：`数据类型[][] 变量名 = {{元素…},{元素…},{元素…}};`
  - 二维数组名+索引：获取一维数组地址名
    - 例如：arr[][]={{},{},..,{}};
    - `syso(arr);` -- 二维数组地址值：例如`[[I@6d06d69c `，两个方括号表示是二维数组。
    - `syso(arr[1]);` -- 二维数组中第二个一维数组的地址值：例如`[I@7852e922 `，一个方括号表示一维数组。
    - 遍历二维数组：
		```java
		int[][] arr2 = {{1,2,3,4},{5,6},{7,8,9}};
		for(int i = 0; i < arr2.length; i++) {
			for(int j = 0; j < arr2[i].length; j++) {
				System.out.print(arr2[i][j]+" ");
			}
			System.out.println();
		}
		```

- ### 数组初始化问题：
  - 二维数组：左侧的方括号可以放在任意插空位置；
  - 静态初始化：右侧可以直接赋值空花括号，不报错。例如`int[] arr = {};`
    - 这样相当于定义了一个长度为0的数组，里面没有元素，`arr[0]`也会越界异常。
    - 如果后期要添加元素，可使用其他容器，比如ArrayList等。
  - 动态初始化：一维必须指定数组长度，二维必须指定前一个方括号中的值(降维为一维理解)。
  - 关于二维数组动态初始化只赋值前一个方括号：
    - 没有指定一维数组的长度，则一维数组在内存中不存在；
    - 长度一旦确定，数组实体就会new出来；
    - 长度不确定，数组实体就还不存在。
    - 示例：`int[][] arr=new int[3][];`
      - `syso(arr)`：输出arr地址值；
      - `syso(arr[0])`：输出null，开辟了空间，但其中的一维数组没有new出来；
      - `syso(arr[0][0])`：空指针异常，arr[0]已经是null为空了，不能操作该数组中的元素。
      - new一维数组：`arr[0] = new int[5];`，之后再打印`[0][0]`就不会空指针异常了。

- ### 地址值概述
  - 示例：`[[I@6d06d69c `
  - `[[`：表示二维数组，如果是一个方括号，表示一维数组；
  - `I`：表示int类型；
  - ` @ `：分隔符；
  - 后面的数字：16进制哈希值，由哈希算法得出，表示实体在内存中的位置。
    - 即：看到哈希值，说明必然有实体。
  - #### 注：打印数组名特例 -- `char[] chs`
    - 数值型数组如int型数组：初始化后直接打印数组名，输出的是地址值。
    - char类型数组输出总结:
      - 直接输出数组名：将数组以字符串形式打印；
      - 输出前面加字符：输出的是地址；
      - 输出前面加字符的情况下想要输出数组内容：Arrays.toString(ch)，数组内容将以数组形式输出：
    - 注：直接打印字符串变量名，输出的也是字符串内容；前面加字符串后，输出的仍是字符串内容。
    - 注：字符串数组直接输出的是地址值。
    - 参考：[【JAVA】java中char类型数组用数组名打印结果不是地址值而是数组内容](https://www.cnblogs.com/anliux/p/12641018.html)

- ### 数组常见问题：
  - 数组索引越界异常：ArrayIndexOutOfBoundsException
    - 产生原因：访问到了数组中的不存在的索引时发生。
  - 空指针异常：NullPointerException
    - 产生原因：数组引用没有指向对象，却在操作对象中的元素或使用数组名访问元素。
      - 例如：`arr=null; syso(arr[1]);`
    - 引用类型：类，接口，数组。
    - 空常量：null，可以赋值给引用类型变量。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## java内存分配
- ### 分类：
  - 栈：存储局部变量；
  - 堆：存储new出来的东西，实体、对象；new：进行空间开辟。
  - 方法区：(面向对象进阶讲)；
  - 本地方法区：(和系统相关)；
  - 寄存器：(给CPU使用)。

- ### 栈：存储局部变量。
  - 栈的读取速度比堆快。
  - 局部变量：定义在方法中的变量；
  - 一旦生命周期结束，即使用完毕后，立即回收。
  - 基本数据类型会一直在栈中创建，当声明基本类型时，不需要new。
  - 基本类型一旦被声明，java将在栈上直接存储它，所以基本类型的变量表示的是数据本身。
  - 假如调用基本类型的包装类来创建对象，那么将会在堆中创建。

- ### 堆：存储new出来的东西，实体、对象。
  - 堆的读取速度比栈慢。
  - 每个对象都有地址值；
  - 每个对象的数据都有默认值：
    - byte, short, int, long: 0;
    - float, double: 0.0;
    - char:'\u0000'; -- unicode编码的空字符。
    - boolean: false;
    - 对象：null.
  - 使用完毕后，会在垃圾回收器空闲的时候回收。

- ### 数组内存：
  - 定义的局部变量arr只存数组实体的地址(引用型变量)；
  - 实体对象在堆内存中，通过new来开辟空间。
  - java中的内存分配图解：
    ![java中的内存分配图解](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/arrays/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%9B%BE%E8%A7%A3.bmp)
  - 一个数组的内存图：
    ![一个数组的内存图](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/arrays/%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.bmp)
  - 两个数组的内存图：
    ![两个数组的内存图](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/arrays/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.bmp)
  - 两个数组指向同一个地址的内存图：
    ![两个数组指向同一个地址的内存图](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/arrays/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.bmp)
  - 静态初始化内存图
    ![静态初始化内存图](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/arrays/%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%9B%BE.bmp)
  - 数组操作的两个常见小问题
    ![数组操作的两个常见小问题](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/arrays/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%B0%8F%E9%97%AE%E9%A2%98.bmp)
  - 数组操作之获取最值图解
    ![数组操作之获取最值图解](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/arrays/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%9C%80%E5%80%BC%E5%9B%BE%E8%A7%A3.bmp)

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 方法
- ### 方法概述
  - 方法就是完成特定功能的代码块
  - 在很多语言里面都有函数的定义
  - 函数在Java中被称为方法

- ### 方法的格式：
  - 方法三要素：函数名，参数列表，结果类型。
  - 格式：
	```java
	修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) {
			函数体;
			return 返回值;
	}
	```
  - 格式解释：
    - 修饰符：public static
    - 返回值类型：用于限定返回值的数据类型
    - 方法名：一个名字，为了方便我们调用方法
    - 参数类型：用于接收调用方法时传入的数据的类型
    - 参数名：用于接收调用方法时传入的数据的变量
    - 方法体：完成功能的代码
    - return：结束方法，把返回值带给调用者(返回值为void时可以省略，或`return;`)
      - 注：return不能写在最前面，否则后面的语句都执行不到了，同`break`。
  - 注意：函数中只能调用函数，不能在函数内部定义函数。（存疑）

- ### 写方法
  - 写一个方法首先有两点需要明确：
    - 返回值类型：明确功能结果的数据类型；
    - 参数列表：明确有几个参数，以及参数的类型。

- ### 方法的调用
  - 方法的一个很重要的特点：不调用不执行。
  - 有明确返回值的方法调用：
    - 单独调用：没有意义；(eg. `sum(10,20);`, 调用了但是什么都没有做，没有联系)
    - 输出调用：有意义，但是不够好，因为不一定非要把结果输出；
    - 赋值调用：推荐方式。
  - 图解：求和方法的调用图解
    ![求和方法的调用图解](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/method/%E6%B1%82%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E5%9B%BE%E8%A7%A3.bmp)
  - 没有明确返回值的方法调用：
    - 其实就是void类型方法的调用(没有返回值类型也不能把返回值类型这里空着)；
    - 参数列表：可以为空，例如`void printHW(){...}`；
    - 只能单独调用，例如`printHW();` -- （是与输出调用和赋值调用相比）。

- ### 方法的重载
  - 方法重载概述：
    - 在同一个类中，方法名相同，参数列表不同的情况。
  - 方法重载特点：
    - 方法名相同，参数列表不同。
      - 参数列表不同：参数个数或者参数类型不同
      - 注：参数列表是有顺序的，`(int, float)`和`(float,int)`也算重载。
      - 注：参数个数不同包括一个是多参数，一个是空参数的情况。
    - 在调用时，java虚拟机通过参数列表的不同来区分同名方法。
    - 注：与返回值类型无关，只看方法名和参数列表
      - 参考`int sum(int a, int b)`和`int sum(int a, int b, int c)；`

- ### 方法参数传递问题
  - 形式参数：用于接收实际参数的变量。
  - 实际参数：实际参与运算的变量。
  - 方法的形式参数是基本数据类型：形式参数的改变不影响实际参数。
  - 图解：
    ![方法的形式参数是基本数据类型](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/method/%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E6%98%AF%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%9B%BE%E8%A7%A3.bmp)
  - 方法的形式参数是引用数据类型：形式参数的改变直接影响实际参数。
    - 传递的是引用型变量的地址值，因此改变后，是对本体进行改变的。
  - 图解：
    ![方法的形式参数是引用数据类型](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/method/%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9B%BE%E8%A7%A3.bmp)

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



## 基础语法练习
- ### 录入月份输出对应季节
  - 记得做非法输入判断 (包含对不属于1-12范围输入的判断)
  - 用switch比if-else判断好一点；
  - 整合相同季节，而不是每个月份数字做一次判断；
  - if-else：可以用或连接多个月份数字，或者用范围；冬季12,1,2用范围不好表示可以放在最后的else里。
  - switch：case穿透，将相同的季节的case放在一起穿透
	```java
	case 3:
	case 4:
	case 5:
		syso("春季");
		break;
	```

- ### 斐波那契数列问题
  - 前两项和等于新的数的数列：1,1,2,3,5,,....
    - 注意第一项和第二项是从几开始的。
    - 跳台阶问题同(跳台阶方法数为斐波那契数列)。
    - 生兔子问题同(兔子总数为斐波那契数列)。
  - 求解方法：
    - 递归；
    - 数组保存每个结果；
    - 用变量保存前两项，并不断更新前两项变量的值。

- ### 评委打分问题
  - 题目：竞赛中有6个评委打分(0-100)，去掉最高分和最低分后的平均分为最后得分，求最终得分。
  - 思路：键盘获取6个打分并存入数组中，写’getMax()‘,’getMin()‘,’getSum()‘三个方法并调用，avg=(sum-max-min)/(arr.length-2)
  - 注：就最简单最质朴的解决思路，没有花里胡哨的技巧

- ### 数组元素反转
  - 双指针从两端向中间遍历，同时交换两指针对应的元素，直到两指针相遇；仔细考虑临界条件!
  - 交换两个数：常规是利用第三方变量；或者利用两数和；或者利用两数异或。
  - 关键代码：`for(int start=0, end=arr.length-1; start<=end; start++,end--){}`
  - 图解
    ![基础语法练习之数组元素反转分析](https://raw.githubusercontent.com/anliux/JAVALearning/master/images/01-java-base/baseTest/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0%E4%B9%8B%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%8F%8D%E8%BD%AC%E5%88%86%E6%9E%90.bmp)

- ### 数组基本查找
  - 题目：定义一个数组，键盘录入被查找数据，写方法得到target第一次出现的索引值
  - 思路：写方法时for循环遍历数组，比较每个元素与target，循环内if判断，相等时返回
  - 注意点：既然是if判断，就有可能全部不符合，但是返回值类型又是一个int型数值，因此需要在for循环外额外加一个`return -1；`
    - 这一点在编程题目中非常常见，引起注意
    
- ### 加密数字
  - 要求对一个四位数的每个位的数字进行各种操作：
    - eg. 每一位数+5, 对10取余，之后1 4位和2 3位交换
    - 可以将每个位的数字拆开，并放入一个数组中，便于操作。
    - 拆开指：`arr[0](千位)=a/10/10/10%10;`, `arr[1]=a/10/10%10;`,`arr[2]=a/10%10;`,`arr[3]=a%10;`

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



### END
